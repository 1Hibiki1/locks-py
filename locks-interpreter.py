import sys
import argparse
from time import time

from locks.lexer.lexer import Lexer
from locks.parser.parser import Parser
from locks.analyzer.analyzer import SemanticAnalyzer
from locks.interpreter.interpreter import Interpeter

from locks.compiler.compiler import Compiler
from locks.assembler.asm import Assembler
from locks.vm.vm import VirtualMachine

from locks.error import Error


def main():
    # setup CLI
    argParser = argparse.ArgumentParser(
        description="locks-py: the locks interpreter"
    )

    argParser.add_argument(
        'path',
        metavar='path',
        type=str,
        help='path to a locks(.lks) file'
    )

    argParser.add_argument(
        '-d',
        '--debug',
        action='store_true',
        help='Use the tree walk interpreter instead of the locks VM to execute code.',
    )

    argParser.add_argument(
        '-b',
        '--bytecode',
        metavar="<output filename>",
        help='Store code generated by compiler in specified file.',
    )

    argParser.add_argument(
        '-v',
        '--viewBytecode',
        action='store_true',
        help='Output code generated by compiler to stdout.',
    )

    args = argParser.parse_args()

    # open and read locks file
    try:
        program = open(args.path, 'r', encoding='unicode_escape').read()
    except FileNotFoundError:
        print(f"Error: file '{args.path}' not found")
        return 1
    except:
        print(f"Error opening file '{args.path}'")
        return 1

    # lexer - split into tokens
    l = Lexer(program)
    tokl = l.getTokens()

    if l.hadError:
        for e in l.getErrorList():
            print(e)
        if args.debug:
            input("\nPress Enter to continue...")
        return -1


    # parser - pass in token list and construct ast
    p = Parser(tokl)
    ast = p.getAST()
    
    if p.hadError:
        for i in p.getError():
            print(i)
        if args.debug:
            input("\nPress Enter to continue...")
        return -1

    # semantic analyser - check ast for static semantic errors
    s = SemanticAnalyzer()
    s.visit(ast)
    if s.hadError:
        for e in s.getErrorList():
            print(e)
        if args.debug:
            input("\nPress Enter to continue...")
        return -1

    # -b specified, output generated code
    if args.bytecode:
        c = Compiler()
        c.visit(ast)
        code = c.getCode()

        outputf = open(args.bytecode, "w")
        outputf.write(code)
        outputf.close()
        return 0

    if args.viewBytecode:
        c = Compiler()
        c.visit(ast)
        print(c.getCode())
        return 0

    # -d specified, use tree walk interpreter
    if args.debug:
        try:
            t0 = time()

            try:
                i = Interpeter()
                i.visit(ast)
            except:
                print("The interpreter crashed! Check the Known Bugs sections in the Locks github repository (https://github.com/1Hibiki1/locks-py) or open an issue.")

            print(f"\nProcess finished in {time() - t0} seconds with return code 0")
            input("Press Enter to continue...")
        except KeyboardInterrupt:
            print("\nKeyboard Interrupt")

            print(f"\nProcess finished in {time() - t0} seconds with return code -1")
            input("Press Enter to continue...")

            return -1
        except Error as e:
            print(e)

            print(f"\nProcess finished in {time() - t0} seconds with return code -1")
            input("Press Enter to continue...")

            return -1

    # run VM
    else:
        try:
            c = Compiler()
            c.visit(ast)
            code = c.getCode()
        except:
            print("\n Compile Error. Exiting...")
            return -1
        
        try:
            a = Assembler(code)
            b = a.getBytecodeList()
            #for i in b:
            #    print(hex(i), end=' ')
            v  = VirtualMachine(b)
            v.run()
        except Error as e:
            print(e)
            return -1

    return 0


if __name__ == '__main__':
    main()
        